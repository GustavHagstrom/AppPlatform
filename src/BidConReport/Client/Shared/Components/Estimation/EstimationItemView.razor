@using BidConReport.Shared.Features.ReportTemplate.Table;

<MudDivider Light="true"/>
<MudStack Row="true" Spacing="1">
    @foreach (var column in ParentComponent.Template.TableSection.Columns)
    {
        <div style="@($"width: {column.Width}%")" class="@($"pl-{NumberOfNestedParentGroups(Item) * 3}")">
            @if(Item.ItemType == EstimationItemType.Group )
            {
                <MudText Style="@($"{ParentComponent.CreateFontStyle(column.GroupFont)}")">@DataSourceFunctions[column.DataSource].Invoke(Item)</MudText>
            }
            else if (Item.ItemType == EstimationItemType.Part)
            {
                <MudText Style="@($"{ParentComponent.CreateFontStyle(column.PartFont)}")">@DataSourceFunctions[column.DataSource].Invoke(Item)</MudText>
            }
            else
            {
                <MudText Style="@($"{ParentComponent.CreateFontStyle(column.CelleFont)}")">@DataSourceFunctions[column.DataSource].Invoke(Item)</MudText>
            }
        
        </div>
    }
</MudStack>

@foreach (var subitem in Item.Items)
{
    <EstimationItemView Item="subitem"/>
}

@code {
    [Parameter, EditorRequired] public required EstimationItem Item { get; set; }
    [CascadingParameter] public required EstimationPreview ParentComponent { get; set; }
    Dictionary<ColumnDataSource, Func<EstimationItem, string>> DataSourceFunctions { get; set; } = new()
    {
        { ColumnDataSource.RowNumber, e => e.RowNumber.ToString() },
        { ColumnDataSource.Name, e => e.Name },
        { ColumnDataSource.Unit, e => e.Unit },
        { ColumnDataSource.DisplayedUnit, e => e.DisplayedUnit },
        { ColumnDataSource.Quantity, e => e.Quantity.ToString() },
        { ColumnDataSource.DisplayedQuantity, e => e.DisplayedQuantity },
        { ColumnDataSource.Comment, e => e.Comment },
    };
    int NumberOfNestedParentGroups(EstimationItem? item)
    {
        if (item is null || item.Parent is null)
        {
            return 0;
        }
        var numberofParentGroups = NumberOfNestedParentGroups(item.Parent);

        if (item.Parent.ItemType is EstimationItemType.Group)
        {
            return numberofParentGroups + 1;
        }
        else
        {
            return numberofParentGroups;
        }
    }
    //IEnumerable<EstimationItem> GetParentsCount(EstimationItem? item, bool isStartingChild = true)
    //{
    //    if (item is not null && !isStartingChild)
    //    {
    //        yield return item;
    //    }
    //    foreach (var parent in GetParentsCount(item))
    //    {
    //        yield return parent;   
    //    }
    //}
}
